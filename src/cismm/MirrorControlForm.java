package cismm;

import ij.IJ;
import ij.gui.PointRoi;
import ij.gui.Roi;
import ij.plugin.filter.GaussianBlur;
import ij.process.ImageProcessor;
import java.awt.HeadlessException;
import java.awt.Point;
import java.awt.Polygon;
import java.awt.geom.AffineTransform;
import java.awt.geom.Point2D;
import java.io.BufferedWriter;
import java.io.File;
import java.io.IOException;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.prefs.BackingStoreException;
import java.util.prefs.Preferences;
//import java.util.prefs.Preferences;
import javax.swing.DefaultComboBoxModel;
import javax.swing.JOptionPane;
import static javax.swing.WindowConstants.HIDE_ON_CLOSE;
import mmcorej.CMMCore;
import mmcorej.DeviceType;
import mmcorej.StrVector;
import mmcorej.TaggedImage;
import org.micromanager.api.ScriptInterface;
import org.micromanager.utils.ImageUtils;
import org.micromanager.utils.JavaUtils;
import org.micromanager.utils.MathFunctions;
import org.micromanager.utils.ReportingUtils;

/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author phsiao
 */
public class MirrorControlForm extends javax.swing.JFrame {

    public static class ExpMode implements Serializable {

        public String mode_name = null;
        public String camera_name = null;
        public String daq_dev_str = null;
        
        AffineTransform first_mapping = null;
        HashMap<Polygon, AffineTransform> poly_mapping = null;
    }
    /**
     * Creates new form MirrorControlForm
     */
    private ScriptInterface app_;
    private CMMCore core_;
    AtomicBoolean isRunning_ = new AtomicBoolean(false);
    AtomicBoolean stopRequested_ = new AtomicBoolean(false);
    private double min_v_x = -10;
    private double max_v_x = 10;
    private double min_v_y = -10;
    private double max_v_y = 10;
    private double v_range_x = max_v_x - min_v_x;
    private double v_range_y = max_v_y - min_v_y;
    private List<String> daq_bin_list_;
    private Process daq_proc = null;
    // The order of the strings must match the order of the tabs on the GUI. 
    List<String> mode_str_array = Arrays.asList("TIRF",
            "PHOTOBLEACHING");
    private ExpMode cur_mode = null;
    //List<String> pin_array = Arrays.asList("Dev1/ao2,Dev1/ao3",
    //                                       "Dev1/ao0,Dev1/ao1");
    Map<String, ExpMode> mode_map = new HashMap<String, ExpMode>();
    BufferedWriter writer_to_daq = null;

//    AffineTransform first_mapping_ = null;
//    Map<Polygon, AffineTransform> poly_mapping_ = null;
    //   Map<String, Map<Polygon, AffineTransform> > mapping_map;
    //   Map<String, AffineTransform> first_mapping_map;
    private void fill_camera_list() {
        StrVector devices = core_.getLoadedDevicesOfType(DeviceType.CameraDevice);
        camera_drop.setModel(new DefaultComboBoxModel(devices.toArray()));
    }

    private void fill_mode_map() {
        loadAllModes();
        /*
         for (String s: mode_str_array) {
         Mode m = new Mode();
         m.mode_name = s;
         mode_map.put(s, m);
         }
         */

//        mode_map.put(mode_array.get(0), "Dev1/ao2,Dev1/ao3");
//        mode_map.put(mode_array.get(1), "Dev1/ao0,Dev1/ao1");
    }

    public MirrorControlForm(CMMCore core, ScriptInterface app, List<String> daq_bin_list) {
        //public MirrorControlForm(List<String> daq_bain_list) {
        initComponents();
        light_mode_drop.setModel(new DefaultComboBoxModel(mode_str_array.toArray()));

        this.setDefaultCloseOperation(HIDE_ON_CLOSE);

        core_ = core;
        app_ = app;

        daq_bin_list_ = daq_bin_list;
        fill_mode_map();
        fill_camera_list();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        tabbed_panel = new javax.swing.JTabbedPane();
        jPanel1 = new javax.swing.JPanel();
        jButton8 = new javax.swing.JButton();
        jLabel21 = new javax.swing.JLabel();
        sample_rate_field = new javax.swing.JTextField();
        jLabel22 = new javax.swing.JLabel();
        jLabel17 = new javax.swing.JLabel();
        jLabel19 = new javax.swing.JLabel();
        tirf_x_input = new javax.swing.JTextField();
        tirf_y_input = new javax.swing.JTextField();
        jLabel24 = new javax.swing.JLabel();
        jPanel4 = new javax.swing.JPanel();
        jLabel25 = new javax.swing.JLabel();
        center_x_field = new javax.swing.JTextField();
        center_y_field = new javax.swing.JTextField();
        detect_center_button = new javax.swing.JButton();
        jLabel26 = new javax.swing.JLabel();
        radius_field = new javax.swing.JTextField();
        jLabel28 = new javax.swing.JLabel();
        num_dots_field = new javax.swing.JTextField();
        freerun_button = new javax.swing.JButton();
        jPanel5 = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jList1 = new javax.swing.JList();
        jButton10 = new javax.swing.JButton();
        jButton11 = new javax.swing.JButton();
        jButton12 = new javax.swing.JButton();
        jButton9 = new javax.swing.JButton();
        jPanel3 = new javax.swing.JPanel();
        point_shoot_button = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        jLabel6 = new javax.swing.JLabel();
        jSpinner1 = new javax.swing.JSpinner();
        jLabel7 = new javax.swing.JLabel();
        jButton2 = new javax.swing.JButton();
        jButton3 = new javax.swing.JButton();
        jLabel8 = new javax.swing.JLabel();
        jLabel9 = new javax.swing.JLabel();
        jLabel10 = new javax.swing.JLabel();
        jLabel11 = new javax.swing.JLabel();
        jLabel12 = new javax.swing.JLabel();
        jSpinner2 = new javax.swing.JSpinner();
        jLabel13 = new javax.swing.JLabel();
        jSpinner3 = new javax.swing.JSpinner();
        jLabel14 = new javax.swing.JLabel();
        jButton4 = new javax.swing.JButton();
        jSeparator1 = new javax.swing.JSeparator();
        point_shoot_x = new javax.swing.JTextField();
        point_shoot_y = new javax.swing.JTextField();
        jPanel2 = new javax.swing.JPanel();
        jPanel7 = new javax.swing.JPanel();
        camera_drop = new javax.swing.JComboBox();
        jLabel15 = new javax.swing.JLabel();
        jLabel33 = new javax.swing.JLabel();
        jLabel34 = new javax.swing.JLabel();
        x_axis_field = new javax.swing.JTextField();
        y_axis_field = new javax.swing.JTextField();
        light_mode_drop = new javax.swing.JComboBox();
        jLabel35 = new javax.swing.JLabel();
        calibration_button = new javax.swing.JButton();
        stop_cabliration_button = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        tabbed_panel.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                tabbed_panelStateChanged(evt);
            }
        });

        jButton8.setText("Submit Loops");

        jLabel21.setText("Circle Frequency:");

        sample_rate_field.setText("30");

        jLabel22.setText("Hz");

        jLabel17.setText("X:");

        jLabel19.setText("Y:");

        tirf_x_input.setText("0");
        tirf_x_input.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                tirf_x_inputActionPerformed(evt);
            }
        });

        tirf_y_input.setText("0");

        jLabel24.setText("(-10, 10) volt");

        jPanel4.setBorder(javax.swing.BorderFactory.createTitledBorder("New Circle"));

        jLabel25.setText("Circle origin (px):");

        center_x_field.setText("0");

        center_y_field.setText("0");

        detect_center_button.setText("Detect Origin");
        detect_center_button.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                detect_center_buttonActionPerformed(evt);
            }
        });

        jLabel26.setText("Radius (px):");

        radius_field.setText("400");

        jLabel28.setText("# of samples:");

        num_dots_field.setText("200");

        freerun_button.setText("Free Run");
        freerun_button.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                freerun_buttonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel4Layout = new javax.swing.GroupLayout(jPanel4);
        jPanel4.setLayout(jPanel4Layout);
        jPanel4Layout.setHorizontalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel4Layout.createSequentialGroup()
                .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(detect_center_button, javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel4Layout.createSequentialGroup()
                        .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel4Layout.createSequentialGroup()
                                .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jLabel25)
                                    .addComponent(jLabel26))
                                .addGap(5, 5, 5))
                            .addGroup(jPanel4Layout.createSequentialGroup()
                                .addComponent(jLabel28)
                                .addGap(21, 21, 21)))
                        .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(num_dots_field, javax.swing.GroupLayout.DEFAULT_SIZE, 76, Short.MAX_VALUE)
                            .addComponent(radius_field)
                            .addComponent(center_x_field))))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(freerun_button, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(center_y_field))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        jPanel4Layout.setVerticalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel4Layout.createSequentialGroup()
                .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel25)
                    .addComponent(center_x_field, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(center_y_field, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel26)
                    .addComponent(radius_field, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel28)
                    .addComponent(num_dots_field, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(detect_center_button)
                    .addComponent(freerun_button)))
        );

        jPanel5.setBorder(javax.swing.BorderFactory.createTitledBorder("Circle Loops"));

        jList1.setModel(new javax.swing.AbstractListModel() {
            String[] strings = { "Item 1", "Item 2", "Item 3", "Item 4", "Item 5" };
            public int getSize() { return strings.length; }
            public Object getElementAt(int i) { return strings[i]; }
        });
        jScrollPane1.setViewportView(jList1);

        jButton10.setText("Delete");

        jButton11.setText("Move Up");

        jButton12.setText("Move Down");

        javax.swing.GroupLayout jPanel5Layout = new javax.swing.GroupLayout(jPanel5);
        jPanel5.setLayout(jPanel5Layout);
        jPanel5Layout.setHorizontalGroup(
            jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel5Layout.createSequentialGroup()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 110, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jButton10, javax.swing.GroupLayout.PREFERRED_SIZE, 89, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jButton11, javax.swing.GroupLayout.PREFERRED_SIZE, 89, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jButton12)))
        );
        jPanel5Layout.setVerticalGroup(
            jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel5Layout.createSequentialGroup()
                .addComponent(jButton10)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jButton11)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jButton12)
                .addGap(0, 20, Short.MAX_VALUE))
            .addComponent(jScrollPane1, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)
        );

        jButton9.setText("Add to Loop");

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, jPanel1Layout.createSequentialGroup()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addGroup(jPanel1Layout.createSequentialGroup()
                                .addComponent(jLabel21)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(sample_rate_field, javax.swing.GroupLayout.PREFERRED_SIZE, 45, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(2, 2, 2)
                                .addComponent(jLabel22)
                                .addGap(18, 18, 18)
                                .addComponent(jButton9))
                            .addComponent(jPanel4, javax.swing.GroupLayout.PREFERRED_SIZE, 257, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jPanel5, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, jPanel1Layout.createSequentialGroup()
                        .addComponent(jLabel17)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(tirf_x_input, javax.swing.GroupLayout.PREFERRED_SIZE, 56, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel19)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(tirf_y_input, javax.swing.GroupLayout.PREFERRED_SIZE, 56, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel24)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jButton8)))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGap(18, 18, 18)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jPanel5, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(jPanel4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jButton9)
                            .addComponent(jLabel21)
                            .addComponent(sample_rate_field, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel22))))
                .addGap(31, 31, 31)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel19)
                    .addComponent(tirf_y_input, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel24)
                    .addComponent(jLabel17)
                    .addComponent(tirf_x_input, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jButton8))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        tabbed_panel.addTab("TIRF", jPanel1);

        point_shoot_button.setText("Point and shoot");
        point_shoot_button.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                point_shoot_buttonActionPerformed(evt);
            }
        });

        jLabel1.setText("Turn off light after:");

        jLabel2.setText("Current target:");

        jLabel3.setText("512");

        jLabel5.setText("320");

        jLabel6.setText("(To phototarget, Ctrl + click on the image)");

        jLabel7.setText("ms");

        jButton2.setText("ROI Manager >>");

        jButton3.setText("Set ROIs");

        jLabel8.setText("No ROIs submitted");

        jLabel9.setText("x:");

        jLabel10.setText("y:");

        jLabel11.setText("Spot dwell time:");

        jLabel12.setText("Loop");

        jSpinner2.setValue(1);

        jLabel13.setText("times");

        jSpinner3.setValue(1);

        jLabel14.setText("ms");

        jButton4.setText("Run ROIs now!");

        jSeparator1.setOrientation(javax.swing.SwingConstants.VERTICAL);

        point_shoot_x.setText("jTextField2");

        point_shoot_y.setText("jTextField3");

        javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);
        jPanel3.setLayout(jPanel3Layout);
        jPanel3Layout.setHorizontalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addGroup(jPanel3Layout.createSequentialGroup()
                            .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                .addComponent(point_shoot_button)
                                .addGroup(jPanel3Layout.createSequentialGroup()
                                    .addComponent(jLabel1)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                    .addComponent(jSpinner1, javax.swing.GroupLayout.PREFERRED_SIZE, 48, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                    .addComponent(jLabel7))
                                .addComponent(jLabel2)
                                .addGroup(jPanel3Layout.createSequentialGroup()
                                    .addComponent(jLabel9)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                    .addComponent(jLabel3)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                    .addComponent(jLabel10)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                    .addComponent(jLabel5)))
                            .addGap(53, 53, 53))
                        .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel3Layout.createSequentialGroup()
                            .addComponent(jLabel6)
                            .addGap(18, 18, 18)))
                    .addGroup(jPanel3Layout.createSequentialGroup()
                        .addComponent(point_shoot_x, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(point_shoot_y, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)))
                .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 15, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(2, 2, 2)
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel3Layout.createSequentialGroup()
                        .addComponent(jLabel12)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jSpinner2)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jLabel13)
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGroup(jPanel3Layout.createSequentialGroup()
                        .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jButton3)
                            .addComponent(jButton2)
                            .addComponent(jLabel8))
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGroup(jPanel3Layout.createSequentialGroup()
                        .addComponent(jButton4)
                        .addGap(131, 147, Short.MAX_VALUE))
                    .addGroup(jPanel3Layout.createSequentialGroup()
                        .addComponent(jLabel11)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jSpinner3, javax.swing.GroupLayout.PREFERRED_SIZE, 49, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jLabel14)
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
        );
        jPanel3Layout.setVerticalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel3Layout.createSequentialGroup()
                        .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(jPanel3Layout.createSequentialGroup()
                                .addComponent(jButton2)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(jButton3)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jLabel8)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(jLabel12)
                                    .addComponent(jSpinner2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(jLabel13))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(jLabel11)
                                    .addComponent(jSpinner3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(jLabel14))
                                .addGap(18, 18, 18)
                                .addComponent(jButton4))
                            .addGroup(jPanel3Layout.createSequentialGroup()
                                .addContainerGap()
                                .addComponent(jLabel6)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(jLabel2)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(jLabel3)
                                    .addComponent(jLabel5)
                                    .addComponent(jLabel9)
                                    .addComponent(jLabel10))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(jLabel1)
                                    .addComponent(jSpinner1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(jLabel7))
                                .addGap(18, 18, 18)
                                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(point_shoot_x, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(point_shoot_y, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addGap(5, 5, 5)
                                .addComponent(point_shoot_button)))
                        .addGap(0, 38, Short.MAX_VALUE))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel3Layout.createSequentialGroup()
                        .addGap(0, 0, Short.MAX_VALUE)
                        .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 207, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap())
        );

        tabbed_panel.addTab("Photobleaching", jPanel3);

        jPanel7.setBorder(javax.swing.BorderFactory.createTitledBorder("Signal Setup"));

        jLabel15.setText("Camera:");

        jLabel33.setText("X Axis:");

        jLabel34.setText("Y Axis:");

        x_axis_field.setText("Dev1/ao0");

        y_axis_field.setText("Dev1/ao1");

        javax.swing.GroupLayout jPanel7Layout = new javax.swing.GroupLayout(jPanel7);
        jPanel7.setLayout(jPanel7Layout);
        jPanel7Layout.setHorizontalGroup(
            jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel7Layout.createSequentialGroup()
                .addGroup(jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addGroup(jPanel7Layout.createSequentialGroup()
                        .addComponent(jLabel15)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(camera_drop, javax.swing.GroupLayout.PREFERRED_SIZE, 82, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(jPanel7Layout.createSequentialGroup()
                        .addComponent(jLabel33)
                        .addGap(18, 18, 18)
                        .addComponent(x_axis_field))
                    .addGroup(jPanel7Layout.createSequentialGroup()
                        .addComponent(jLabel34)
                        .addGap(18, 18, 18)
                        .addComponent(y_axis_field)))
                .addGap(0, 31, Short.MAX_VALUE))
        );
        jPanel7Layout.setVerticalGroup(
            jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel7Layout.createSequentialGroup()
                .addGroup(jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(camera_drop, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel15))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel33)
                    .addComponent(x_axis_field, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addGroup(jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel34)
                    .addComponent(y_axis_field, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(14, Short.MAX_VALUE))
        );

        jLabel35.setText("Calibration for");

        calibration_button.setText("Calibrate Now!");
        calibration_button.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                calibration_buttonActionPerformed(evt);
            }
        });

        stop_cabliration_button.setText("Stop");

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                        .addComponent(jPanel7, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGroup(jPanel2Layout.createSequentialGroup()
                            .addComponent(jLabel35)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addComponent(light_mode_drop, 0, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addComponent(calibration_button)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(stop_cabliration_button)))
                .addContainerGap(314, Short.MAX_VALUE))
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(light_mode_drop, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel35))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jPanel7, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(calibration_button)
                    .addComponent(stop_cabliration_button))
                .addContainerGap(28, Short.MAX_VALUE))
        );

        tabbed_panel.addTab(" Hardware Calibration", jPanel2);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(tabbed_panel)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(tabbed_panel, javax.swing.GroupLayout.PREFERRED_SIZE, 252, javax.swing.GroupLayout.PREFERRED_SIZE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /*
     private String getPinStr(LightMode mode) {
     switch(mode) {
     case TIRF:
     return pin_array;
     case PHOTOBLEACHING:
     return pb_pin;
     default:
     break;
     }
     return null;      
     }
     */
    private static Point[] getVertices(Polygon polygon) {
        Point vertices[] = new Point[polygon.npoints];
        for (int i = 0; i < polygon.npoints; ++i) {
            vertices[i] = new Point(polygon.xpoints[i], polygon.ypoints[i]);
        }
        return vertices;
    }

    /**
     * Gets the vectorial mean of an array of Points.
     */
    private static Point2D.Double meanPosition2D(Point[] points) {
        double xsum = 0;
        double ysum = 0;
        int n = points.length;
        for (int i = 0; i < n; ++i) {
            xsum += points[i].x;
            ysum += points[i].y;
        }
        return new Point2D.Double(xsum / n, ysum / n);
    }

    private Point2D.Double transformPoint(Map<Polygon, AffineTransform> mapping, Point2D.Double pt) {
        Set<Polygon> set = mapping.keySet();
        // First find out if the given point is inside a cell, and if so,
        // transform it with that cell's AffineTransform.

        for (Polygon poly : set) {
            if (poly.contains(pt)) {
                return (Point2D.Double) mapping.get(poly).transform(pt, null);
            }
        }

        // The point isn't inside any cell, so use the global mapping
        return (Point2D.Double) cur_mode.first_mapping.transform(pt, null);

        // The point isn't inside any cell, so search for the closest cell
        // and use the AffineTransform from that.
        /*
         double minDistance = Double.MAX_VALUE;
         Polygon bestPoly = null;
         for (Polygon poly : set) {
         double distance = meanPosition2D(getVertices(poly)).distance(pt.x, pt.y);
         if (minDistance > distance) {
         bestPoly = poly;
         minDistance = distance;
         }
         }
         if (bestPoly == null) {
         throw new RuntimeException("Unable to map point to device.");
         }
         return (Point2D.Double) mapping.get(bestPoly).transform(pt, null);
         */
    }

    /**
     * Simple utility methods for points
     *
     * Adds a point to an existing polygon.
     */
    private static void addVertex(Polygon polygon, Point p) {
        polygon.addPoint(p.x, p.y);
    }

    /**
     * Converts a Point with double values for x,y to a point with x and y
     * rounded to the nearest integer.
     */
    private static Point toIntPoint(Point2D.Double pt) {
        return new Point((int) (0.5 + pt.x), (int) (0.5 + pt.y));
    }

    /**
     * Converts a Point with integer values to a Point with x and y doubles.
     */
    private static Point2D.Double toDoublePoint(Point pt) {
        return new Point2D.Double(pt.x, pt.y);
    }

    /**
     * Illuminate a spot at position x,y.
     */
    private void displaySpot(double x, double y) {
        if (x >= min_v_x && x <= (v_range_x + min_v_x)
                && y >= min_v_y && y <= (v_range_y + min_v_y)) {
            //String pin_str = getPinStr(LightMode.TIRF);
            two_ao_update(cur_mode.daq_dev_str, Double.toString(x), Double.toString(y));
        }
    }

    public static Point findMaxPixel(ImageProcessor proc) {

        // If there is no signal, return a point at (-2, -2)
        int[] min_max = ImageUtils.getMinMax(proc.getPixels());
        if (min_max[0] == 0) {
            min_max[0] = 1;
        }
        //JOptionPane.showMessageDialog(IJ.getImage().getWindow(), "min:" + String.valueOf(min_max[0])
        //        + " max:" + String.valueOf(min_max[1]));

        if ((int) min_max[1] / (int) min_max[0] < 5) {
            return new Point(-2, -2);
        }

        int width = proc.getWidth();
        int imax = ImageUtils.findArrayMax(proc.getPixels());

        int y = imax / width;
        int x = imax % width;
        return new Point(x, y);
    }

    // Find the brightest spot in an ImageProcessor. The image is first blurred
    // and then the pixel with maximum intensity is returned.
    private static Point findPeak(ImageProcessor proc) {
        ImageProcessor blurImage = proc.duplicate();
        blurImage.setRoi((Roi) null);
        GaussianBlur blur = new GaussianBlur();
        blur.blurGaussian(blurImage, 3, 3, 0.01);
        //showProcessor("findPeak",proc);
        //Point x = ImageUtils.findMaxPixel(blurImage);
        Point x = findMaxPixel(blurImage);
        x.translate(1, 1);
        return x;
    }

    /**
     * Display a spot using the projection device, and return its current
     * location on the camera. Does not do sub-pixel localization, but could
     * (just would change its return type, most other code would be OK with
     * this)
     */
    private Point measureSpotOnCamera(Point2D.Double projectionPoint, boolean addToAlbum) {
        if (stopRequested_.get()) {
            return null;
        }
        try {

            displaySpot(projectionPoint.x, projectionPoint.y);
            core_.snapImage();
            TaggedImage image = core_.getTaggedImage();
            ImageProcessor proc1 = ImageUtils.makeMonochromeProcessor(image);
            Point maxPt = findPeak(proc1);
            // JonD: should use the exposure that the user has set to avoid hardcoding a value;
            // if the user wants a different exposure time for calibration it's easy to specify
            // => commenting out next two lines
            // long originalExposure = dev_.getExposure();
            // dev_.setExposure(500000);

            // NS: Timing between displaySpot and snapImage is critical
            // we have no idea how fast the device will respond
            // if we add "dev_.waitForDevice(), then the RAPP UGA-40 will already have ended
            // its exposure before returning control
            // For now, wait for a user specified delay

            //int delayMs = Integer.parseInt(delayField_.getText());
            //Thread.sleep(delayMs);

            //core_.snapImage();
            // NS: just make sure to wait until the spot is no longer displayed
            // JonD: time to wait is simply the exposure time less any delay

            // Maybe we need this??
            // Thread.sleep((int) (dev_.getExposure()/1000) - delayMs);

            // JonD: see earlier comment => commenting out next line
            // dev_.setExposure(originalExposure);
            //TaggedImage taggedImage2 = core_.getTaggedImage();
            //ImageProcessor proc2 = ImageUtils.makeMonochromeProcessor(taggedImage2);
            //app_.displayImage(taggedImage2);
            // saving images to album is useful for debugging
            // TODO figure out why this doesn't work towards the end; maybe limitation on # of images in album
            // if (addToAlbum) {
            //    app_.addToAlbum(taggedImage2);
            // }
            //ImageProcessor diffImage = ImageUtils.subtractImageProcessors(proc2.convertToFloatProcessor(), proc1.convertToFloatProcessor());
            //app_.closeAcquisitionWindow(app_.getSnapLiveWin().getName());
            //app_.closeAllAcquisitions();


            app_.displayImage(image);
            app_.getSnapLiveWin().getImagePlus().setRoi(new PointRoi(maxPt.x, maxPt.y));


            // NS: what is this second sleep good for????
            // core_.sleep(500);
            return maxPt;
        } catch (Exception e) {
            ReportingUtils.showError(e);
            return null;
        }
    }

    /**
     * Illuminate a spot at ptSLM, measure its location on the camera, and add
     * the resulting point pair to the spotMap.
     */
    private void measureAndAddToSpotMap(Map<Point2D.Double, Point2D.Double> spotMap,
            Point2D.Double ptSLM) {
        Point ptCam = measureSpotOnCamera(ptSLM, false);
        if (ptCam.x >= 0) {
            Point2D.Double ptCamDouble = new Point2D.Double(ptCam.x, ptCam.y);
            spotMap.put(ptCamDouble, ptSLM);
        }
    }

    /**
     * Illuminates and images five control points near the center, and return an
     * affine transform mapping from image coordinates to phototargeter
     * coordinates.
     */
    private AffineTransform generateLinearMapping() {
        //double centerX = v_range_x / 2 + min_v_x;
        //double centerY = v_range_y / 2 + min_v_y;
        double spacing = Math.min(v_range_x, v_range_y) / 10;  // use 10% of galvo/SLM range
        Map<Point2D.Double, Point2D.Double> big_map = new HashMap<Point2D.Double, Point2D.Double>();

        for (double i = min_v_x; i <= max_v_x; i += spacing) {
            for (double j = min_v_y; j <= max_v_y; j += spacing) {
                measureAndAddToSpotMap(big_map, new Point2D.Double(i, j));
            }
        }
        /*
         measureAndAddToSpotMap(spotMap, new Point2D.Double(centerX, centerY));
         measureAndAddToSpotMap(spotMap, new Point2D.Double(centerX, centerY + spacing));
         measureAndAddToSpotMap(spotMap, new Point2D.Double(centerX + spacing, centerY));
         measureAndAddToSpotMap(spotMap, new Point2D.Double(centerX, centerY - spacing));
         measureAndAddToSpotMap(spotMap, new Point2D.Double(centerX - spacing, centerY));
         */
        if (stopRequested_.get()) {
            return null;
        }
        try {
            // require that the RMS value between the mapped points and the measured points be less than 5% of image size
            // also require that the RMS value be less than the spacing between points in the galvo/SLM coordinate system
            // (2nd requirement was probably the intent of the code until r15505, but parameters were interchanged in call) 
            final long imageSize = Math.min(core_.getImageWidth(), core_.getImageHeight());
            //return MathFunctions.generateAffineTransformFromPointPairs(spotMap, imageSize * 0.05, spacing);
            return MathFunctions.generateAffineTransformFromPointPairs(big_map);
        } catch (Exception e) {
            throw new RuntimeException("Spots aren't detected as expected. Is DMD in focus and roughly centered in camera's field of view?");
        }
    }

    /**
     * Generate a nonlinear calibration mapping for the current device settings.
     * A rectangular lattice of points is illuminated one-by-one on the
     * projection device, and locations in camera pixels of corresponding spots
     * on the camera image are recorded. For each rectangular cell in the grid,
     * we take the four point mappings (camera to projector) and generate a
     * local AffineTransform using linear least squares. Cells with suspect
     * measured corner positions are discarded. A mapping of cell polygon to
     * AffineTransform is generated.
     */
    private Map<Polygon, AffineTransform> generateNonlinearMapping() {

        // get the affine transform near the center spot
        cur_mode.first_mapping = generateLinearMapping();

        // then use this single transform to estimate what SLM coordinates 
        // correspond to the image's corner positions 
//        final Point2D.Double camCorner1 = (Point2D.Double) firstApproxAffine.transform(new Point2D.Double(0, 0), null);
//        final Point2D.Double camCorner2 = (Point2D.Double) firstApproxAffine.transform(new Point2D.Double((int) core_.getImageWidth(), (int) core_.getImageHeight()), null);
//        final Point2D.Double camCorner3 = (Point2D.Double) firstApproxAffine.transform(new Point2D.Double(0, (int) core_.getImageHeight()), null);
//        final Point2D.Double camCorner4 = (Point2D.Double) firstApproxAffine.transform(new Point2D.Double((int) core_.getImageWidth(), 0), null);

        // figure out camera's bounds in SLM coordinates
        // min/max because we don't know the relative orientation of the camera and SLM
        // do some extra checking in case camera/SLM aren't at exactly 90 degrees from each other, 
        // but still better that they are at 0, 90, 180, or 270 degrees from each other
        // TODO can create grid along camera location instead of SLM's if camera is the limiting factor; this will make arbitrary rotation possible
//        final double camLeft = Math.min(Math.min(Math.min(camCorner1.x, camCorner2.x), camCorner3.x), camCorner4.x);
//        final double camRight = Math.max(Math.max(Math.max(camCorner1.x, camCorner2.x), camCorner3.x), camCorner4.x);
//        final double camTop = Math.min(Math.min(Math.min(camCorner1.y, camCorner2.y), camCorner3.y), camCorner4.y);
//        final double camBottom = Math.max(Math.max(Math.max(camCorner1.y, camCorner2.y), camCorner3.y), camCorner4.y);

        // these are the SLM's bounds
//        final double slmLeft = min_v_x;
//        final double slmRight = v_range_x + min_v_x;
//        final double slmTop = min_v_y;
//        final double slmBottom = v_range_y + min_v_y;

        // figure out the "overlap region" where both the camera and SLM
        // can "see", expressed in SLM coordinates
//        final double left = Math.max(camLeft, slmLeft);
//        final double right = Math.min(camRight, slmRight);
//        final double top = Math.max(camTop, slmTop);
//        final double bottom = Math.min(camBottom, slmBottom);
//        final double width = right - left;
//        final double height = bottom - top;



        // compute a grid of SLM points inside the "overlap region"
        // nGrid is how many polygons in both X and Y
        // require (nGrid + 1)^2 spot measurements to get nGrid^2 squares
        // TODO allow user to change nGrid
        final int nGrid = 7;
        Point2D.Double slmPoint[][] = new Point2D.Double[1 + nGrid][1 + nGrid];
        Point2D.Double camPoint[][] = new Point2D.Double[1 + nGrid][1 + nGrid];

        final int padding = 10;
        final int cam_width = (int) core_.getImageWidth() - padding * 2;
        final int cam_height = (int) core_.getImageHeight() - padding * 2;
        final double cam_step_x = cam_width / nGrid;
        final double cam_step_y = cam_height / nGrid;

        for (int i = 0; i <= nGrid; i++) {
            for (int j = 0; j <= nGrid; j++) {
                slmPoint[i][j] = (Point2D.Double) cur_mode.first_mapping.transform(
                        new Point2D.Double(cam_step_x * i + padding,
                        cam_step_y * j + padding), null);
            }
        }
        // tabulate the camera spot at each of SLM grid points
        for (int i = 0; i <= nGrid; ++i) {
            for (int j = 0; j <= nGrid; ++j) {
                Point spot = measureSpotOnCamera(slmPoint[i][j], true);
                if (spot != null) {
                    camPoint[i][j] = toDoublePoint(spot);
                }
            }
        }

        if (stopRequested_.get()) {
            return null;
        }

        // now make a grid of (square) polygons (in camera's coordinate system)
        // and generate an affine transform for each of these square regions
        Map<Polygon, AffineTransform> bigMap = new HashMap<Polygon, AffineTransform>();
        for (int i = 0; i <= nGrid - 1; ++i) {
            for (int j = 0; j <= nGrid - 1; ++j) {
                Polygon poly = new Polygon();
                addVertex(poly, toIntPoint(camPoint[i][j]));
                addVertex(poly, toIntPoint(camPoint[i][j + 1]));
                addVertex(poly, toIntPoint(camPoint[i + 1][j + 1]));
                addVertex(poly, toIntPoint(camPoint[i + 1][j]));

                Map<Point2D.Double, Point2D.Double> map = new HashMap<Point2D.Double, Point2D.Double>();
                map.put(camPoint[i][j], slmPoint[i][j]);
                map.put(camPoint[i][j + 1], slmPoint[i][j + 1]);
                map.put(camPoint[i + 1][j], slmPoint[i + 1][j]);
                map.put(camPoint[i + 1][j + 1], slmPoint[i + 1][j + 1]);
                double srcDX = Math.abs((camPoint[i + 1][j].x - camPoint[i][j].x)) / 4;
                double srcDY = Math.abs((camPoint[i][j + 1].y - camPoint[i][j].y)) / 4;
                double srcTol = Math.max(srcDX, srcDY);

                try {
                    AffineTransform transform = MathFunctions.generateAffineTransformFromPointPairs(map, srcTol, Double.MAX_VALUE);
                    bigMap.put(poly, transform);
                } catch (Exception e) {
                    ReportingUtils.logError("Bad cell in mapping.");
                }
            }
        }
        return bigMap;
    }

    private Preferences getCalibrationNode() {
        try {
            Preferences p = Preferences.userNodeForPackage(DualAxisMirrorPlugin.class)
                    .node("calibration")
                    .node("abc");
            p.flush();
            return p;
        } catch (NullPointerException npe) {
            return null;
        } catch (BackingStoreException ex) {
            Logger.getLogger(MirrorControlForm.class.getName()).log(Level.SEVERE, null, ex);
        }
        return null;
    }

    private void loadAllModes() {
        Preferences prefs = getCalibrationNode();
        if (prefs == null) {
            return;
        }

        String nodeStr = prefs.toString();
        System.out.print(nodeStr);

        for (String key : mode_str_array) {
            ExpMode m = (ExpMode) JavaUtils.getObjectFromPrefs(prefs, key, new ExpMode());
            mode_map.put(key, m);
        }

        /*
         String nodeStr = prefs.toString();
        
         if (mappingNode_ == null || !nodeStr.contentEquals(mappingNode_)) {
         mappingNode_ = nodeStr;
         mapping_ = (Map<Polygon, AffineTransform>) JavaUtils.getObjectFromPrefs(
         prefs,
         dev_.getName(),
         new HashMap<Polygon, AffineTransform>());
         }
         return mapping_;
         */
    }

    private void saveToDisk(ExpMode mode) {
        Preferences p = getCalibrationNode();       
        JavaUtils.putObjectInPrefs(p, mode.mode_name, mode);
    }

    private void calibration_buttonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_calibration_buttonActionPerformed

        final boolean liveModeRunning = app_.isLiveModeOn();
        app_.enableLiveMode(false);
        if (!isRunning_.get()) {
            stopRequested_.set(false);

            cur_mode = mode_map.get(light_mode_drop.getSelectedItem().toString());

            if (camera_drop.getItemCount() == 0) {
                JOptionPane.showMessageDialog(null,
                        "Empty Camera");
                return;
            }
            if (x_axis_field.getText().isEmpty()) {
                JOptionPane.showMessageDialog(null,
                        "Need to speicy x-axis signal");
                return;
            }
            if (y_axis_field.getText().isEmpty()) {
                JOptionPane.showMessageDialog(null,
                        "Need to speicy y-axis signal");
                return;
            }

            cur_mode.mode_name = light_mode_drop.getSelectedItem().toString();
            cur_mode.camera_name = camera_drop.getSelectedItem().toString();
            cur_mode.daq_dev_str = x_axis_field.getText() + "," + y_axis_field.getText();
            

            //if (cur_mode.camera_name != null && cur_mode.daq_dev_str != null)
            /*
             Thread th = new Thread("Projector calibration thread") {
             @Override
             public void run() {
             try {
             isRunning_.set(true);
             Roi originalROI = IJ.getImage().getRoi();
             cur_mode.poly_mapping =
             (HashMap<Polygon, AffineTransform>) generateNonlinearMapping();

             app_.enableLiveMode(liveModeRunning);
             JOptionPane.showMessageDialog(IJ.getImage().getWindow(), "Calibration "
             + (!stopRequested_.get() ? "finished." : "canceled."));
             IJ.getImage().setRoi(originalROI);

             } catch (HeadlessException e) {
             ReportingUtils.showError(e);
             } catch (RuntimeException e) {
             ReportingUtils.showError(e);
             } finally {
             isRunning_.set(false);
             stopRequested_.set(false);
             //calibration_button.setText("Calibrate");

             }
             }
             };
             th.start();
             */
            saveToDisk(cur_mode);
        }


    }//GEN-LAST:event_calibration_buttonActionPerformed

    /**
     * Load the mapping for the current calibration node. The mapping maps each
     * polygon cell to an AffineTransform.
     */
    public void two_ao_update(String channel_str, String xv, String yv) {
        try {

            ProcessBuilder pb = new ProcessBuilder(System.getProperty("user.dir")
                    + File.separator + "mmplugins" + File.separator
                    + "two_ao_update.exe", channel_str, xv, yv);//.redirectErrorStream(true);
            daq_proc = pb.start();

            daq_proc.getInputStream().close();
            daq_proc.getOutputStream().close();
            daq_proc.getErrorStream().close();

            daq_proc.waitFor();
            daq_proc.destroy();
        } catch (IOException ex) {
            Logger.getLogger(MirrorControlForm.class.getName()).log(Level.SEVERE, null, ex);
        } catch (InterruptedException ex) {
            Logger.getLogger(MirrorControlForm.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    private void tirf_x_inputActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_tirf_x_inputActionPerformed

        System.out.print("x pressed");// TODO add your handling code here:        
        two_ao_update("dev1/ao0,dev1/ao1", "3", "3");
        two_ao_update("dev1/ao0,dev1/ao1", "0", "0");
    }//GEN-LAST:event_tirf_x_inputActionPerformed

//    // Creates a MouseListener instance for future use with Point and Shoot
//   // mode. When the MouseListener is attached to an ImageJ window, any
//   // clicks will result in a spot being illuminated.
//   private MouseListener createPointAndShootMouseListenerInstance() {
//      return new MouseAdapter() {
//         @Override
//         public void mouseClicked(MouseEvent e) {
//            if (e.isShiftDown()) {
//               Point p = e.getPoint();
//               ImageCanvas canvas = (ImageCanvas) e.getSource();
//               Point pOffscreen = new Point(canvas.offScreenX(p.x), canvas.offScreenY(p.y));
//               final Point2D.Double devP = transformAndMirrorPoint(loadMapping(), canvas.getImage(),
//                       new Point2D.Double(pOffscreen.x, pOffscreen.y));
//               final Configuration originalConfig = prepareChannel();
//               final boolean originalShutterState = prepareShutter();
//               makeRunnableAsync(
//                       new Runnable() {
//                          @Override
//                          public void run() {
//                             try {
//                                if (devP != null) {
//                                   displaySpot(devP.x, devP.y);
//                                }
//                                returnShutter(originalShutterState);
//                                returnChannel(originalConfig);
//                             } catch (Exception e) {
//                                ReportingUtils.showError(e);
//                             }
//                          }
//                       }).run();
//
//            }
//         }
//      };
//   }
    private void point_shoot_buttonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_point_shoot_buttonActionPerformed

        double x = Double.parseDouble(point_shoot_x.getText());
        double y = Double.parseDouble(point_shoot_y.getText());

        Point2D.Double img_pos = new Point2D.Double(x, y);

        Point2D.Double volts = transformPoint(cur_mode.poly_mapping, img_pos);

        // TODO REMOVE THIS LINE!!!!!
        cur_mode = mode_map.get(mode_str_array.get(0));

        displaySpot(volts.x, volts.y);
    }//GEN-LAST:event_point_shoot_buttonActionPerformed

    private void tabbed_panelStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_tabbed_panelStateChanged
        int tab_ind = tabbed_panel.getSelectedIndex();
        if (tab_ind < 2) {
            cur_mode = mode_map.get(mode_str_array.get(tab_ind));
        }
//        mapping_ = mapping_map.get(cur_mode);
        //first_mapping_ = first_mapping_map.get(tabbed_panel.getSelectedIndex());
        //mapping_ = mapping_map.get(tabbed_panel.getSelectedIndex());
    }//GEN-LAST:event_tabbed_panelStateChanged

    private List<Double> create_circle_dots() {
        List<Double> ret = new ArrayList<Double>();
        int center_x = Integer.parseInt(center_x_field.getText());
        int center_y = Integer.parseInt(center_y_field.getText());

        int num_dots = Integer.parseInt(num_dots_field.getText());
        int radius = Integer.parseInt(radius_field.getText());

        double unit_angle = (360.0 / num_dots) * (Math.PI / 180.0);

        for (int i = 0; i < num_dots; i++) {
            double dot_x = Math.cos(unit_angle * i) * radius + center_x;
            double dot_y = Math.sin(unit_angle * i) * radius + center_y;

            ret.add(dot_x);
            ret.add(dot_y);

        }
        //System.out.print(ret.toString());
        return ret;
    }

    public void freerun(List<String> args) {
        try {
            String app = System.getProperty("user.dir")
                    + File.separator + "mmplugins" + File.separator
                    + "freerun.exe";

            args.add(0, app);

            ProcessBuilder pb = new ProcessBuilder(args);
            daq_proc = pb.start();

        } catch (IOException ex) {
            Logger.getLogger(MirrorControlForm.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    private void startFreerun() {
        /*
         if (mapping_ == null)
         return;
         */

        final List<Double> combined = create_circle_dots();
        /*
         final List<Double> combined = new ArrayList<Double>();
         combined.add(400.0);
         combined.add(400.0);
         combined.add(500.0);
         combined.add(400.0);
         combined.add(500.0);
         combined.add(500.0);
         combined.add(400.0);
         combined.add(500.0);
         */
        final List<String> transformed_points = new ArrayList<String>();


        for (int i = 0; i < combined.size() - 1; i += 2) {
            Point2D.Double p = new Point2D.Double(combined.get(i), combined.get(i + 1));
            Point2D.Double trans_p = transformPoint(cur_mode.poly_mapping, p);

            transformed_points.add(String.valueOf(trans_p.x));
            transformed_points.add(String.valueOf(trans_p.y));
        }

        // example: run dev1/ao0,dev1/ao1 rate 6 x1 y1 x2 y2 x3 y3
        List<String> args = Arrays.asList(cur_mode.daq_dev_str,
                sample_rate_field.getText(),
                Integer.toString(transformed_points.size()));

        transformed_points.addAll(0, args);

        final boolean liveModeRunning = app_.isLiveModeOn();
        if (!isRunning_.get()) {
            stopRequested_.set(false);
            Thread th = new Thread("Projector calibration thread") {
                @Override
                public void run() {
                    try {
                        isRunning_.set(true);
                        freerun(transformed_points);

                        app_.enableLiveMode(liveModeRunning);
                    } catch (HeadlessException e) {
                        ReportingUtils.showError(e);
                    } catch (RuntimeException e) {
                        ReportingUtils.showError(e);
                    } finally {
                        //isRunning_.set(false);
                        //stopRequested_.set(false);
                        //calibration_button.setText("Calibrate");     
                    }
                }
            };
            th.start();
        }
    }

    private void stopFreerun() {
        daq_proc.destroy();
        isRunning_.set(false);
    }

    private void freerun_buttonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_freerun_buttonActionPerformed

        /*
         if (mapping_ == null) {
         JOptionPane.showMessageDialog(null,
         "Calibrate the mirror first");
         return;
         }
         */
        boolean running = isRunning_.get();
        if (running) {
            stopFreerun();
            freerun_button.setText("Free Run Selected");
        } else {
            startFreerun();
            freerun_button.setText("Stop Free Run");
        }
    }//GEN-LAST:event_freerun_buttonActionPerformed

    private void detect_center_buttonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_detect_center_buttonActionPerformed

        // TODO Find a way to loop through all modes without hard-coded index
        Point2D.Double zero_v = new Point2D.Double(0, 0);
        cur_mode = mode_map.get(mode_str_array.get(1));
        displaySpot(0, 0);
        cur_mode = mode_map.get(mode_str_array.get(0));
        Point p = measureSpotOnCamera(zero_v, false);

        this.center_x_field.setText(Integer.toString(p.x));
        this.center_y_field.setText(Integer.toString(p.y));
    }//GEN-LAST:event_detect_center_buttonActionPerformed
    /**
     * @param args the command line arguments
     */
//    public static void main(String args[]) {
//        /* Set the Nimbus look and feel */
//        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
//        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
//         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
//         */
//        try {
//            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
//                if ("Nimbus".equals(info.getName())) {
//                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
//                    break;
//                }
//            }
//        } catch (ClassNotFoundException ex) {
//            java.util.logging.Logger.getLogger(MirrorControlForm.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
//        } catch (InstantiationException ex) {
//            java.util.logging.Logger.getLogger(MirrorControlForm.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
//        } catch (IllegalAccessException ex) {
//            java.util.logging.Logger.getLogger(MirrorControlForm.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
//        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
//            java.util.logging.Logger.getLogger(MirrorControlForm.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
//        }
//        //</editor-fold>
//
//        /* Create and display the form */
//        java.awt.EventQueue.invokeLater(new Runnable() {
//            public void run() {
//                new MirrorControlForm().setVisible(true);
//            }
//        });
//    }                    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton calibration_button;
    private javax.swing.JComboBox camera_drop;
    private javax.swing.JTextField center_x_field;
    private javax.swing.JTextField center_y_field;
    private javax.swing.JButton detect_center_button;
    private javax.swing.JButton freerun_button;
    private javax.swing.JButton jButton10;
    private javax.swing.JButton jButton11;
    private javax.swing.JButton jButton12;
    private javax.swing.JButton jButton2;
    private javax.swing.JButton jButton3;
    private javax.swing.JButton jButton4;
    private javax.swing.JButton jButton8;
    private javax.swing.JButton jButton9;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel11;
    private javax.swing.JLabel jLabel12;
    private javax.swing.JLabel jLabel13;
    private javax.swing.JLabel jLabel14;
    private javax.swing.JLabel jLabel15;
    private javax.swing.JLabel jLabel17;
    private javax.swing.JLabel jLabel19;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel21;
    private javax.swing.JLabel jLabel22;
    private javax.swing.JLabel jLabel24;
    private javax.swing.JLabel jLabel25;
    private javax.swing.JLabel jLabel26;
    private javax.swing.JLabel jLabel28;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel33;
    private javax.swing.JLabel jLabel34;
    private javax.swing.JLabel jLabel35;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JList jList1;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JPanel jPanel4;
    private javax.swing.JPanel jPanel5;
    private javax.swing.JPanel jPanel7;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JSeparator jSeparator1;
    private javax.swing.JSpinner jSpinner1;
    private javax.swing.JSpinner jSpinner2;
    private javax.swing.JSpinner jSpinner3;
    private javax.swing.JComboBox light_mode_drop;
    private javax.swing.JTextField num_dots_field;
    private javax.swing.JButton point_shoot_button;
    private javax.swing.JTextField point_shoot_x;
    private javax.swing.JTextField point_shoot_y;
    private javax.swing.JTextField radius_field;
    private javax.swing.JTextField sample_rate_field;
    private javax.swing.JButton stop_cabliration_button;
    private javax.swing.JTabbedPane tabbed_panel;
    private javax.swing.JTextField tirf_x_input;
    private javax.swing.JTextField tirf_y_input;
    private javax.swing.JTextField x_axis_field;
    private javax.swing.JTextField y_axis_field;
    // End of variables declaration//GEN-END:variables
}
